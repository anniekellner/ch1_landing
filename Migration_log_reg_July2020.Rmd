---
title: "Migration_Log_Reg"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
load("logreg.RData")

library(dplyr)
library(MuMIn)
```

## Logistic Regression using all data points
### Variables: Maximum SIC w/in 30 km radius, Reproductive Status, Distance to Land, 
### Don't bother with this - should distill data to one point per day

```{r, echo = FALSE}
fit_d2l <- glm(leave.ice ~ dist2land, data = logreg, family = binomial())
summary(fit_d2l)

fit_max <- glm(leave.ice ~ SIC_30m_max, data = logreg, family = binomial())
summary(fit_max)

fit_repro <- glm(leave.ice ~ repro, data = logreg, family = binomial())
summary(fit_repro)

fit_repro_max <- glm(leave.ice ~ repro + SIC_30m_max, data = logreg, family = binomial())

fit_d2l_max <- glm(leave.ice ~ dist2land + SIC_30m_max, data = logreg, family = binomial())

fit_d2l_max_repro <- glm(leave.ice ~ repro + SIC_30m_max + dist2land, data = logreg, family = binomial())

aicc <- AICc(fit_max, fit_d2l, fit_repro, fit_repro_max, fit_d2l_max, fit_d2l_max_repro)

# Learn how to call functions from another script

create_AICc_table(aicc) # From MyFunctions.R
```

# Results are cleaner when d2l is not included as a single model. Maybe d2l is absorbing too much variation. 

# Exploring ways to categorize reproduction

# Add reproductive status 
# 0 = none/unknown
# 1 = denning
# 2 = coy
# 3 = yearling 
# NOTE: combine coy and yearling and see if effect is different

```{r}
logreg$repro <- 0

all.v2 <- all.v2 %>%
  mutate(repro = replace(repro, DenYr == 1, 1)) %>%
  mutate(repro = replace(repro, coy == 1, 2)) %>%
  mutate(repro = replace(repro, yearling == 1, 3))
```

# Repro2
0 = no young or no data
1 = coy or yearling

# Repro 3
0 = anything but coy
1 = coy

# Repro4
0 = no data
1 = denning
2 = yearling
3 = coy


```{r}
# Repro 2
logreg$repro2 <- ifelse(logreg$repro == 2 | logreg$repro == 3, 1, 0) # 1 = coy OR yearling

# Repro 3
logreg$repro3 <- ifelse(logreg$repro == 2, 1, 0) # 1 = coy only

# Repro 4

logreg$repro4 <- 0

logreg <- logreg %>%
  mutate(repro4 = replace(repro4, repro == 1, 1)) %>%
  mutate(repro4 = replace(repro4, repro == 2, 3)) %>%
  mutate(repro4 = replace(repro4, repro == 3, 2))


repro  <- glm(leave.ice ~ repro, data = logreg, family = binomial(link = 'logit'))
repro2 <- glm(leave.ice ~ repro2, data = logreg, family = binomial(link = 'logit'))
repro3 <- glm(leave.ice ~ repro3, data = logreg, family = binomial(link = 'logit'))
repro4 <- glm(leave.ice ~ repro4, data = logreg, family = binomial(link = 'logit'))


aicc <- AICc(repro, repro2, repro3, repro4)

create_AICc_table(aicc)
aicc

summary(repro)
summary(repro2)
summary(repro3)
summary(repro4)

```
### Best way to handle reproduction is to make sure Repro is categorical (factor) in R. 

```{r, echo=FALSE}
fit_d2l <- glm(leave.ice ~ dist2land, data = loc1, family = binomial())
summary(fit_d2l)

fit_max <- glm(leave.ice ~ SIC_30m_max, data = loc1, family = binomial())
summary(fit_max)

fit_repro <- glm(leave.ice ~ repro, data = loc1, family = binomial())
summary(fit_repro)

fit_repro_max <- glm(leave.ice ~ repro + SIC_30m_max, data = loc1, family = binomial())

fit_d2l_max <- glm(leave.ice ~ dist2land + SIC_30m_max, data = loc1, family = binomial())

fit_d2l_max_repro <- glm(leave.ice ~ repro + SIC_30m_max + dist2land, data = loc1, family = binomial())

aicc <- AICc(fit_max, fit_d2l, fit_repro,fit_repro_max, fit_d2l_max, fit_d2l_max_repro)

# Learn how to call functions from another script

create_AICc_table(aicc) # From MyFunctions.R
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
